#include "GrayLevelImage2D.hpp"
#include <string> // chaînes de caractères
#include <fstream> // flux sur les fichiers
#include <sstream> // flux sur les chaînes de caractères

using namespace std;
GrayLevelImage2D::GrayLevelImage2D(){
  m_width = 0;
  m_height = 0;
}


GrayLevelImage2D::GrayLevelImage2D( int w, int h, GrayLevel g){
  m_data.resize(w * h, g);
  m_width = w;
  m_height = h;
}


void GrayLevelImage2D::fill( GrayLevelImage2D::GrayLevel g ){}

void GrayLevelImage2D::resize(int w, int h){
  m_data.resize(w * h);
  m_width = w;
  m_height = h;
}

//! [gli2d-sec3]
/// @return la largeur de l'image.
int GrayLevelImage2D::w() const{
  return m_width;
}

/// @return la hauteur de l'image.
int GrayLevelImage2D::h() const{
  return m_height;
}

  /**
     Accesseur read-only à la valeur d'un pixel.
     @return la valeur du pixel(i,j)
  */
GrayLevelImage2D::GrayLevel GrayLevelImage2D::at( int i, int j ) const{
  return m_data.at(offset(i, j));
}

  /**
     Accesseur read-write à la valeur d'un pixel.
     @return une référence à la valeur du pixel(i,j)
  */
GrayLevelImage2D::GrayLevel& GrayLevelImage2D::at( int i, int j ){
  return m_data.at(offset(i, j));
}
  //! [gli2d-sec3]



GrayLevelImage2D::Iterator GrayLevelImage2D::begin(){
  return Iterator(*this, 0,0);
}
GrayLevelImage2D::Iterator GrayLevelImage2D::end(){
  return Iterator(*this, 0, h());
}
GrayLevelImage2D::Iterator GrayLevelImage2D::start( int x, int y ){
  return Iterator(*this, x, y);
}
bool GrayLevelImage2D::importPGM( std::istream & input ){
  if (input.good()){
    std::string s;
    std::string commentary;
    std::getline(input, s);
    std::getline(input, commentary);
    int w, h, cmax;
    input>>w>>h>>cmax;
    resize(w,h);
    if (s[1] == '5'){
      char lect;
      input >> std::noskipws;
      for (int i = 0; i < w; i++){
          for (int j = 0; j < h; j++){
              input >> lect;
              at(i, j) = lect;
          }
      }
    }else{
      int lect;
      for (int i = 0; i < w; i++){
          for (int j = 0; j < h; j++){
              input >> lect;
              at(i, j) = lect;
          }
      }
    }
    return true;
  }else{
    return false;
  }
}

bool GrayLevelImage2D::exportPGM( std::ostream & output, bool ascii = false ){
    if (ascii){
        output<<"P2";
    }else{
        output<<"P5";
    }
    output<<endl<<"#generated by us"<<endl<<h()<<' '<<w()<<endl<<255<<endl;
    for (int i = 0; i < w(); i++){
        for (int j = 0; j < h(); j++){
            if(ascii){
                output<<(int)at(i, j);
            }else {
                output<<(char)at(i,j);
            }
        }
    }
  return true;

}

// retourne l'indice dans le tableau a une dimension
int GrayLevelImage2D::offset( int x, int y ) const{
  
  return y * w() + x;
}

GrayLevelImage2D::Iterator::Iterator( GrayLevelImage2D& Image, int x, int y )
  :std::vector<GrayLevel>::iterator(Image.m_data.begin() + Image.offset(x, y)){};

